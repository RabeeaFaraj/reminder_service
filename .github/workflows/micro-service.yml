name: Reminder Service CI/CD Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  # Job 1: Run Unit Tests
  unit-tests:
    runs-on: ubuntu-latest
    name: Unit Tests & Code Quality
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install allure-pytest  # Add Allure support
        
    - name: Run unit tests
      run: |
        # Run tests with Allure reporting
        pytest -v --alluredir=allure-results
        
    - name: Upload Allure Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: unit-tests-allure-results
        path: allure-results/
        retention-days: 30
        
    - name: Code linting with flake8
      run: |
        pip install flake8
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        
    - name: Generate test coverage report
      run: |
        pip install coverage
        coverage run -m unittest discover tests
        coverage report
        coverage xml
        
    - name: Upload coverage to artifact
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: coverage.xml

  # Job 2: Build and Deploy Docker Image
  build-and-deploy:
    runs-on: ubuntu-latest
    needs: unit-tests
    outputs:
      REMINDER_SERVICE_VERSION: ${{ steps.parse_env.outputs.REMINDER_SERVICE_VERSION }}
      IMAGE_TAG: ${{ steps.build_image.outputs.IMAGE_TAG }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Auto-increment version and build
      id: build_image
      run: |
        # Read current version
        if [ ! -f VERSION ]; then
          echo "0.0.1" > VERSION
        fi
        
        CURRENT_VERSION=$(cat VERSION)
        echo "Current version: $CURRENT_VERSION"
        
        # Parse and increment patch version
        IFS='.' read -r -a version_parts <<< "$CURRENT_VERSION"
        major="${version_parts[0]}"
        minor="${version_parts[1]}"
        patch="${version_parts[2]}"
        patch=$((patch + 1))
        NEW_VERSION="$major.$minor.$patch"
        
        echo "New version: $NEW_VERSION"
        echo "$NEW_VERSION" > VERSION
        
        # Create unique tag with commit SHA
        TAG="$NEW_VERSION-${{ github.sha }}"
        echo "IMAGE_TAG=$TAG" >> $GITHUB_OUTPUT
        echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT
        
        # Login to DockerHub
        echo ${{ secrets.DOCKERHUB_PASSWORD }} | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin
        
        # Build and push the image
        docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/reminder-service:$TAG .
        docker tag ${{ secrets.DOCKERHUB_USERNAME }}/reminder-service:$TAG ${{ secrets.DOCKERHUB_USERNAME }}/reminder-service:latest
        
        docker push ${{ secrets.DOCKERHUB_USERNAME }}/reminder-service:$TAG
        docker push ${{ secrets.DOCKERHUB_USERNAME }}/reminder-service:latest
        
        echo "Built and pushed: ${{ secrets.DOCKERHUB_USERNAME }}/reminder-service:$TAG"

    - name: Copy deployment files to EC2
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        source: "./docker-compose.yml,./Dockerfile,./.dockerignore"
        target: "/home/ubuntu/reminder-service/"
        
    - name: Create .env file for EC2
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        source: ".env"
        target: "/home/ubuntu/reminder-service/"

    - name: Deploy to EC2
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          cd /home/ubuntu/reminder-service
          
          # Stop ALL existing containers and clean up
          echo "=== Stopping and cleaning up existing containers ==="
          docker compose down --remove-orphans || true
          docker container prune -f || true
          
          # Kill any processes using port 8000
          echo "=== Checking for processes using port 8000 ==="
          lsof -ti:8000 | xargs -r kill -9 || echo "No processes found on port 8000"
          
          # Clean up any dangling containers
          docker ps -a --filter "name=reminder-service" --format "{{.ID}}" | xargs -r docker rm -f || true
          
          # Setup environment file
          cp .env .env
          
          # Update .env with deployment values
          echo "REMINDER_SERVICE_VERSION=${{ steps.build_image.outputs.NEW_VERSION }}" >> .env
          echo "DOCKER_IMAGE_TAG=${{ steps.build_image.outputs.IMAGE_TAG }}" >> .env
          echo "WEKAN_BASE_URL=http://localhost" >> .env
          echo "WEKAN_PORT=80" >> .env
          
          # Add AWS region and SNS topic (you'll need to set these as secrets)
          echo "AWS_DEFAULT_REGION=${{ secrets.AWS_DEFAULT_REGION }}" >> .env
          echo "SNS_TOPIC_ARN=${{ secrets.SNS_TOPIC_ARN }}" >> .env
          
          # Verify port 8000 is free
          echo "=== Verifying port 8000 is available ==="
          if lsof -Pi :8000 -sTCP:LISTEN -t >/dev/null ; then
            echo "ERROR: Port 8000 is still in use!"
            lsof -Pi :8000 -sTCP:LISTEN
            exit 1
          else
            echo "✅ Port 8000 is available"
          fi
          
          # Pull latest image and start services
          echo "=== Pulling latest images ==="
          docker compose pull
          
          echo "=== Starting services ==="
          docker compose up -d
          
          # Wait for service to be ready
          sleep 30
          
          # Health check
          echo "=== Checking service status ==="
          docker compose ps
          echo "=== Testing health endpoint ==="
          curl -f http://localhost:8000/health || echo "Health check failed"

    - id: parse_env
      name: Parse environment values
      run: |
        REMINDER_SERVICE_VERSION="${{ steps.build_image.outputs.NEW_VERSION }}"
        echo "REMINDER_SERVICE_VERSION=$REMINDER_SERVICE_VERSION" >> $GITHUB_OUTPUT
        echo "REMINDER_SERVICE_VERSION=$REMINDER_SERVICE_VERSION" >> $GITHUB_ENV
        
        echo "Exported REMINDER_SERVICE_VERSION=$REMINDER_SERVICE_VERSION"

  # Job 3: API Integration Tests
  api-tests:
    runs-on: ubuntu-latest
    needs: build-and-deploy
    name: API Integration Tests
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install testing dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pytest httpx requests pytest-html pytest-json-report allure-pytest
        
        # Verify allure-pytest is installed and working
        pytest --version
        python -c "import allure; print('✅ Allure module imported successfully')"
        echo "✅ All testing dependencies installed successfully"
        
    - name: Wait for service to be ready
      run: |
        echo "Waiting for reminder service to be ready..."
        for i in {1..30}; do
          if curl -f http://${{ secrets.EC2_HOST }}:8000/health; then
            echo "Service is ready!"
            break
          fi
          echo "Attempt $i: Service not ready, waiting..."
          sleep 10
        done
        
    - name: Upload API Test Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: api-tests-allure-results
        path: allure-results/
        retention-days: 30

  # Job 4: Performance & Load Tests
  performance-tests:
    runs-on: ubuntu-latest
    needs: build-and-deploy
    name: Performance Tests
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install performance testing tools
      run: |
        sudo apt-get update
        sudo apt-get install -y apache2-utils curl jq
        
    - name: Basic load test with Apache Bench
      run: |
        echo "Running load test on health endpoint..."
        ab -n 100 -c 10 http://${{ secrets.EC2_HOST }}:8000/health
        
        echo "Running load test on status endpoint..."
        ab -n 50 -c 5 http://${{ secrets.EC2_HOST }}:8000/status
        
    - name: Response time test
      run: |
        echo "Testing response times..."
        for endpoint in health status; do
          echo "Testing /$endpoint endpoint:"
          for i in {1..5}; do
            curl -w "Response time: %{time_total}s\n" -s -o /dev/null \
              http://${{ secrets.EC2_HOST }}:8000/$endpoint
          done
        done

  # Job 5: Security Tests  
  security-tests:
    runs-on: ubuntu-latest
    needs: build-and-deploy
    name: Security Tests
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run basic security scans
      run: |
        # Install security testing tools
        pip install safety bandit
        
        # Check for known security vulnerabilities in dependencies
        echo "Checking for security vulnerabilities..."
        safety check -r requirements.txt || echo "Security vulnerabilities found"
        
        # Static security analysis
        echo "Running static security analysis..."
        bandit -r . -f json -o bandit-report.json || echo "Security issues found"
        
    - name: Upload security scan results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-scan-results
        path: bandit-report.json
        retention-days: 30

  # Job 6: Generate Allure Report
  generate-allure-report:
    runs-on: ubuntu-latest
    needs: [unit-tests, build-and-deploy, api-tests, performance-tests, security-tests]
    if: always()
    name: Generate Allure Test Report
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install Allure CLI via npm
      run: |
        # Install global allure-commandline package which bundles the Allure CLI
        npm install -g allure-commandline --no-progress || true
        # verify
        if command -v allure >/dev/null 2>&1; then
          allure --version || true
        else
          echo "Allure CLI not found after npm install"
          npm list -g --depth=0 || true
          exit 1
        fi
        
    - name: Download all test artifacts
      uses: actions/download-artifact@v4
      with:
        path: test-results
        
    - name: Prepare test results for Allure
      run: |
        mkdir -p allure-results
        mkdir -p allure-report
        
        # Create environment properties for Allure
        cat > allure-results/environment.properties << EOF
        Service=Reminder Service
        Version=${{ needs.build-and-deploy.outputs.REMINDER_SERVICE_VERSION }}
        Image.Tag=${{ needs.build-and-deploy.outputs.IMAGE_TAG }}
        Environment=${{ github.event.inputs.environment || 'staging' }}
        Commit=${{ github.sha }}
        Branch=${{ github.ref_name }}
        EC2.Host=${{ secrets.EC2_HOST }}
        Docker.Repository=${{ secrets.DOCKERHUB_USERNAME }}/reminder-service
        Build.Date=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        EOF
        
        # Create categories for test classification
        cat > allure-results/categories.json << 'EOF'
        [
          {
            "name": "Unit Tests",
            "messageRegex": ".*unit.*",
            "traceRegex": ".*unit.*"
          },
          {
            "name": "API Integration Tests", 
            "messageRegex": ".*api.*",
            "traceRegex": ".*api.*"
          },
          {
            "name": "Performance Tests",
            "messageRegex": ".*performance.*",
            "traceRegex": ".*performance.*"
          },
          {
            "name": "Security Tests",
            "messageRegex": ".*security.*",
            "traceRegex": ".*security.*"
          },
          {
            "name": "Infrastructure Issues",
            "messageRegex": ".*connection.*|.*timeout.*|.*network.*"
          }
        ]
        EOF
        
    - name: Create Allure test results from pipeline data
      run: |
        # No additional dependencies needed - using standard Python libraries
        
        # Create a Python script to convert pipeline results to Allure format
        cat > create_allure_results.py << 'EOF'
        import json
        import os
        import uuid
        from datetime import datetime
        
        def create_test_result(name, status, description="", duration=0, error_message=""):
            """Create an Allure test result JSON"""
            test_uuid = str(uuid.uuid4())
            
            result = {
                "uuid": test_uuid,
                "historyId": name.replace(" ", "_").lower(),
                "name": name,
                "fullName": f"Pipeline.{name.replace(' ', '_')}",
                "labels": [
                    {"name": "suite", "value": "CI/CD Pipeline"},
                    {"name": "story", "value": "Automated Testing"},
                    {"name": "framework", "value": "GitHub Actions"}
                ],
                "status": status,
                "statusDetails": {
                    "message": error_message if error_message else f"{name} completed",
                    "trace": error_message if error_message else ""
                },
                "stage": "finished",
                "description": description,
                "start": int(datetime.now().timestamp() * 1000) - duration * 1000,
                "stop": int(datetime.now().timestamp() * 1000)
            }
            
            return result
        
        # Pipeline job results
        jobs = [
            {
                "name": "Unit Tests & Code Quality",
                "status": "${{ needs.unit-tests.result }}",
                "description": "Runs unit tests, code linting, and coverage analysis"
            },
            {
                "name": "Build & Deploy to EC2", 
                "status": "${{ needs.build-and-deploy.result }}",
                "description": "Builds Docker image and deploys to EC2 instance"
            },
            {
                "name": "API Integration Tests",
                "status": "${{ needs.api-tests.result }}",
                "description": "Tests live API endpoints on deployed service"
            },
            {
                "name": "Performance & Load Tests",
                "status": "${{ needs.performance-tests.result }}",
                "description": "Load testing and response time validation"
            },
            {
                "name": "Security Tests",
                "status": "${{ needs.security-tests.result }}",
                "description": "Security vulnerability scanning and analysis"
            }
        ]
        
        # Convert GitHub Actions status to Allure status
        def convert_status(gh_status):
            status_map = {
                "success": "passed",
                "failure": "failed", 
                "cancelled": "broken",
                "skipped": "skipped"
            }
            return status_map.get(gh_status, "unknown")
        
        # Create Allure test results
        for i, job in enumerate(jobs):
            allure_status = convert_status(job["status"])
            error_msg = f"Job failed with status: {job['status']}" if allure_status == "failed" else ""
            
            result = create_test_result(
                name=job["name"],
                status=allure_status,
                description=job["description"],
                duration=30,  # Estimated duration
                error_message=error_msg
            )
            
            # Generate unique test UUID for this result
            test_uuid = result["uuid"]
            
            # Write individual test result
            with open(f"allure-results/{test_uuid}-result.json", "w") as f:
                json.dump(result, f, indent=2)
        
        print("Created Allure test results for all pipeline jobs")
        EOF
        
        # Run the script to create test results
        python create_allure_results.py
        
    - name: Generate Allure Report
      run: |
        # Generate the Allure report
        allure generate allure-results --output allure-report --clean
        
        # Add custom information to the report
        echo "Allure report generated successfully"
        echo "Report contains results from:"
        echo "- Unit Tests: ${{ needs.unit-tests.result }}"
        echo "- Build & Deploy: ${{ needs.build-and-deploy.result }}"
        echo "- API Tests: ${{ needs.api-tests.result }}"
        echo "- Performance Tests: ${{ needs.performance-tests.result }}"
        echo "- Security Tests: ${{ needs.security-tests.result }}"
        
    - name: Upload Allure Report
      uses: actions/upload-artifact@v4
      with:
        name: allure-report
        path: allure-report/
        retention-days: 90
        
    - name: Deploy Allure Report to GitHub Pages
      if: github.ref == 'refs/heads/main'
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: allure-report
        destination_dir: allure-reports/${{ github.run_number }}
        
    - name: Comment PR with Allure Report Link
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `## 📊 Allure Test Report
            
            **Pipeline Results:**
            - ✅ Unit Tests: ${{ needs.unit-tests.result }}
            - ✅ Build & Deploy: ${{ needs.build-and-deploy.result }} 
            - ✅ API Tests: ${{ needs.api-tests.result }}
            - ✅ Performance: ${{ needs.performance-tests.result }}
            - ✅ Security: ${{ needs.security-tests.result }}
            
            **Service Info:**
            - Version: ${{ needs.build-and-deploy.outputs.REMINDER_SERVICE_VERSION }}
            - Image: ${{ needs.build-and-deploy.outputs.IMAGE_TAG }}
            
            📋 [View Detailed Allure Report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            🔗 [Service Health Check](http://${{ secrets.EC2_HOST }}:8000/health)
            📚 [API Documentation](http://${{ secrets.EC2_HOST }}:8000/docs)`
          })

  # Job 7: Cleanup on failure
  cleanup-on-failure:
    runs-on: ubuntu-latest
    needs: [build-and-deploy, api-tests]
    if: failure()
    
    steps:
    - name: Cleanup failed deployment
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          echo "Cleaning up failed deployment..."
          cd /home/ubuntu/reminder-service
          docker compose down || true
          docker system prune -f || true